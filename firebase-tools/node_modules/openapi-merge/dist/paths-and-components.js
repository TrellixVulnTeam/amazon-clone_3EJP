"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const atlassian_openapi_1 = require("atlassian-openapi");
const reference_walker_1 = require("./reference-walker");
const lodash_1 = __importDefault(require("lodash"));
const operation_selection_1 = require("./operation-selection");
function removeFromStart(input, trim) {
    if (input.startsWith(trim)) {
        return input.substring(trim.length);
    }
    return input;
}
function referenceCount(walker, component) {
    let count = 0;
    walker(component, ref => { count++; return ref; });
    return count;
}
function componentsEqual(referenceWalker) {
    return (x, y) => {
        if (!lodash_1.default.isEqual(x, y)) {
            return false;
        }
        if (atlassian_openapi_1.SwaggerTypeChecks.isReference(x)) {
            return false;
        }
        return referenceCount(referenceWalker, x) === 0;
    };
}
function processComponents(results, components, areEqual, disputePrefix, addModifiedReference) {
    for (const key in components) {
        /* eslint-disable-next-line no-prototype-builtins */
        if (components.hasOwnProperty(key)) {
            const component = components[key];
            if (results[key] === undefined || areEqual(results[key], component)) {
                // Add the schema
                results[key] = component;
            }
            else {
                // Distnguish the name and then add the element
                let schemaPlaced = false;
                // Try and use the dispute prefix first
                if (disputePrefix !== undefined) {
                    const preferredSchemaKey = `${disputePrefix}${key}`;
                    if (results[preferredSchemaKey] === undefined || areEqual(results[preferredSchemaKey], component)) {
                        results[preferredSchemaKey] = component;
                        addModifiedReference(key, preferredSchemaKey);
                        schemaPlaced = true;
                    }
                }
                // Incrementally find the right prefix
                for (let antiConflict = 1; schemaPlaced === false && antiConflict < 1000; antiConflict++) {
                    const trySchemaKey = `${key}${antiConflict}`;
                    if (results[trySchemaKey] === undefined) {
                        results[trySchemaKey] = component;
                        addModifiedReference(key, trySchemaKey);
                        schemaPlaced = true;
                    }
                }
                // In the unlikely event that we can't find a duplicate, return an error
                if (schemaPlaced === false) {
                    return {
                        type: 'component-definition-conflict',
                        message: `The "${key}" definition had a duplicate in a previous input and could not be deduplicated.`
                    };
                }
            }
        }
    }
}
function countOperationsInPathItem(pathItem) {
    let count = 0;
    count += pathItem.get !== undefined ? 1 : 0;
    count += pathItem.put !== undefined ? 1 : 0;
    count += pathItem.post !== undefined ? 1 : 0;
    count += pathItem.delete !== undefined ? 1 : 0;
    count += pathItem.options !== undefined ? 1 : 0;
    count += pathItem.head !== undefined ? 1 : 0;
    count += pathItem.patch !== undefined ? 1 : 0;
    count += pathItem.trace !== undefined ? 1 : 0;
    return count;
}
function dropPathItemsWithNoOperations(originalOas) {
    const oas = lodash_1.default.cloneDeep(originalOas);
    for (const path in oas.paths) {
        /* eslint-disable-next-line no-prototype-builtins */
        if (oas.paths.hasOwnProperty(path)) {
            const pathItem = oas.paths[path];
            if (countOperationsInPathItem(pathItem) === 0) {
                delete oas.paths[path];
            }
        }
    }
    return oas;
}
/**
 * Merge algorithm:
 *
 * Generate reference mappings for the components. Eliminating duplicates.
 * Generate reference mappings for the paths.
 * Copy the elements into the new location.
 * Update all of the paths and components to the new references.
 *
 * @param inputs
 */
function mergePathsAndComponents(inputs) {
    const result = {
        paths: {},
        components: {},
    };
    for (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
        const input = inputs[inputIndex];
        const { oas: originalOas, disputePrefix, pathModification, operationSelection } = input;
        const oas = dropPathItemsWithNoOperations(operation_selection_1.runOperationSelection(lodash_1.default.cloneDeep(originalOas), operationSelection));
        // Original references will be transformed to new non-conflicting references
        const referenceModification = {};
        // For each component in the original input, place it in the output with deduplicate taking place
        if (oas.components !== undefined) {
            if (oas.components.schemas !== undefined) {
                result.components.schemas = result.components.schemas || {};
                processComponents(result.components.schemas, oas.components.schemas, componentsEqual(reference_walker_1.walkSchemaReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/schemas/${from}`] = `#/components/schemas/${to}`;
                });
            }
            if (oas.components.responses !== undefined) {
                result.components.responses = result.components.responses || {};
                processComponents(result.components.responses, oas.components.responses, componentsEqual(reference_walker_1.walkResponseReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/responses/${from}`] = `#/components/responses/${to}`;
                });
            }
            if (oas.components.parameters !== undefined) {
                result.components.parameters = result.components.parameters || {};
                processComponents(result.components.parameters, oas.components.parameters, componentsEqual(reference_walker_1.walkParameterReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/parameters/${from}`] = `#/components/parameters/${to}`;
                });
            }
            // examples
            if (oas.components.examples !== undefined) {
                result.components.examples = result.components.examples || {};
                processComponents(result.components.examples, oas.components.examples, componentsEqual(reference_walker_1.walkExampleReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/examples/${from}`] = `#/components/examples/${to}`;
                });
            }
            // requestBodies
            if (oas.components.requestBodies !== undefined) {
                result.components.requestBodies = result.components.requestBodies || {};
                processComponents(result.components.requestBodies, oas.components.requestBodies, componentsEqual(reference_walker_1.walkRequestBodyReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/requestBodies/${from}`] = `#/components/requestBodies/${to}`;
                });
            }
            // headers
            if (oas.components.headers !== undefined) {
                result.components.headers = result.components.headers || {};
                processComponents(result.components.headers, oas.components.headers, componentsEqual(reference_walker_1.walkHeaderReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/headers/${from}`] = `#/components/headers/${to}`;
                });
            }
            // security schemes are different, we just take the security schemes from the first file that has any
            if (oas.components.securitySchemes !== undefined && Object.keys(oas.components.securitySchemes).length > 0 && result.components.securitySchemes === undefined) {
                result.components.securitySchemes = oas.components.securitySchemes;
            }
            // links
            if (oas.components.links !== undefined) {
                result.components.links = result.components.links || {};
                processComponents(result.components.links, oas.components.links, componentsEqual(reference_walker_1.walkLinkReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/links/${from}`] = `#/components/links/${to}`;
                });
            }
            // callbacks
            if (oas.components.callbacks !== undefined) {
                result.components.callbacks = result.components.callbacks || {};
                processComponents(result.components.callbacks, oas.components.callbacks, componentsEqual(reference_walker_1.walkCallbackReferences), disputePrefix, (from, to) => {
                    referenceModification[`#/components/callbacks/${from}`] = `#/components/callbacks/${to}`;
                });
            }
        }
        // For each path, convert it into the right format (looking out for duplicates)
        const paths = Object.keys(oas.paths);
        for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            const originalPath = paths[pathIndex];
            const newPath = pathModification === undefined ? originalPath : `${pathModification.prepend || ''}${removeFromStart(originalPath, pathModification.stripStart || '')}`;
            if (originalPath !== newPath) {
                referenceModification[`#/paths/${originalPath}`] = `#/paths/${newPath}`;
            }
            // TODO perform more advanced matching for an existing path than an equals check
            if (result.paths[newPath] !== undefined) {
                return {
                    type: 'duplicate-paths',
                    message: `Input ${inputIndex}: The path '${originalPath}' maps to '${newPath}' and this has already been added by another input file`
                };
            }
            result.paths[newPath] = oas.paths[originalPath];
        }
        // Update the references to point to the right location
        const modifiedKeys = Object.keys(referenceModification);
        reference_walker_1.walkAllReferences(oas, ref => {
            if (referenceModification[ref] !== undefined) {
                return referenceModification[ref];
            }
            const matchingKeys = modifiedKeys.filter(key => key.startsWith(`${ref}/`));
            if (matchingKeys.length > 1) {
                throw new Error(`Found more than one matching key for reference '${ref}': ${JSON.stringify(matchingKeys)}`);
            }
            else if (matchingKeys.length === 1) {
                return referenceModification[matchingKeys[0]];
            }
            return ref;
        });
    }
    return result;
}
exports.mergePathsAndComponents = mergePathsAndComponents;
